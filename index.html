<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVENT HORIZON | 事件视界导航系统</title>
    <style>
        /* ==================== 全局设定 ==================== */
        :root {
            --neon-blue: #00f3ff;
            --neon-warn: #ff3300;
            --hud-bg: rgba(0, 10, 20, 0.25);
            --border-color: rgba(0, 243, 255, 0.3);
        }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', monospace; }
        canvas { display: block; position: fixed; top: 0; left: 0; z-index: 1; }

        /* ==================== 顶部遮罩 (宽银幕感) ==================== */
        .cinematic-bar {
            position: fixed; top: 0; left: 0; width: 100%; height: 80px;
            background: linear-gradient(to bottom, #000 0%, transparent 100%);
            z-index: 5; display: flex; justify-content: space-between; padding: 20px 40px; box-sizing: border-box;
            color: var(--neon-blue); font-size: 12px; opacity: 0.8; pointer-events: none;
        }
        .warning-text { color: var(--neon-warn); animation: blink 1s infinite; }

        /* ==================== 底部全息仪表盘容器 ==================== */
        #hud-container {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 35vh;
            z-index: 10;
            display: grid;
            grid-template-columns: 1fr 2fr 1fr; /* 左-中-右 布局 */
            gap: 20px;
            padding: 0 40px 20px 40px;
            box-sizing: border-box;
            /* 3D 透视，营造驾驶舱感觉 */
            perspective: 1000px;
            pointer-events: none; /* 允许点击穿透空白区域 */
        }

        /* 通用面板样式 */
        .panel {
            background: var(--hud-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            backdrop-filter: blur(8px);
            padding: 15px;
            position: relative;
            /* 面板轻微向内倾斜 */
            transform-style: preserve-3d;
            transform: rotateX(10deg);
            pointer-events: auto; /* 恢复交互 */
            display: flex; flex-direction: column;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.1), inset 0 0 20px rgba(0, 243, 255, 0.05);
        }

        /* 装饰角标 */
        .panel::after {
            content: ''; position: absolute; bottom: -1px; right: -1px;
            width: 20px; height: 20px;
            border-bottom: 2px solid var(--neon-blue);
            border-right: 2px solid var(--neon-blue);
        }
        .panel::before {
            content: ''; position: absolute; top: -1px; left: -1px;
            width: 20px; height: 20px;
            border-top: 2px solid var(--neon-blue);
            border-left: 2px solid var(--neon-blue);
        }

        /* === 左侧：引擎状态 === */
        .left-panel { transform: rotateY(15deg) rotateX(10deg); align-items: flex-end; text-align: right; }
        .data-row { width: 100%; display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 12px; color: rgba(255,255,255,0.7); }
        .bar-chart { width: 100%; height: 40px; display: flex; align-items: flex-end; gap: 4px; margin-top: auto; }
        .bar { width: 10%; background: var(--neon-blue); opacity: 0.5; animation: eq-bounce 1s infinite alternate; }
        
        /* === 右侧：雷达系统 === */
        .right-panel { transform: rotateY(-15deg) rotateX(10deg); align-items: center; justify-content: center; }
        .radar-circle {
            width: 120px; height: 120px; border: 1px dashed var(--neon-blue); border-radius: 50%;
            position: relative;
            background: radial-gradient(circle, rgba(0, 243, 255, 0.1) 0%, transparent 70%);
        }
        .radar-scan {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 50%;
            background: conic-gradient(from 0deg, transparent 0deg, rgba(0, 243, 255, 0.4) 60deg, transparent 60.1deg);
            animation: radar-spin 4s linear infinite;
        }

        /* === 中间：主导航 (重头戏) === */
        .center-panel {
            transform: rotateX(10deg) translateZ(20px); /* 中间突前一点 */
            border: none; background: transparent; box-shadow: none; backdrop-filter: none;
            justify-content: flex-end; padding-bottom: 0;
        }

        .nav-grid {
            display: flex; gap: 15px; justify-content: center; width: 100%;
        }

        .nav-btn {
            position: relative;
            width: 140px; height: 80px;
            background: rgba(0, 20, 30, 0.8);
            border: 1px solid var(--neon-blue);
            color: #fff;
            text-decoration: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            clip-path: polygon(15% 0, 100% 0, 100% 85%, 85% 100%, 0 100%, 0 15%);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        
        /* 按钮内发光文字 */
        .nav-btn h3 { margin: 0; font-size: 16px; letter-spacing: 2px; z-index: 2; text-shadow: 0 0 5px var(--neon-blue); }
        .nav-btn span { font-size: 10px; color: var(--neon-blue); opacity: 0.7; z-index: 2; margin-top: 4px; }

        /* 按钮悬停态 */
        .nav-btn:hover {
            background: rgba(0, 243, 255, 0.15);
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 10px 30px rgba(0, 243, 255, 0.2);
            border-color: #fff;
        }
        .nav-btn:hover span { color: #fff; }

        /* 按钮扫描线特效 */
        .nav-btn::after {
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: linear-gradient(transparent, rgba(0, 243, 255, 0.3), transparent);
            transform: rotate(45deg) translateY(-100%);
            transition: transform 0s;
        }
        .nav-btn:hover::after {
            transform: rotate(45deg) translateY(100%);
            transition: transform 0.6s ease-in-out;
        }

        /* 动画定义 */
        @keyframes radar-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        @keyframes eq-bounce { 0% { height: 20%; } 100% { height: 90%; } }

        /* 移动端适配 */
        @media (max-width: 768px) {
            #hud-container { grid-template-columns: 1fr; height: auto; }
            .left-panel, .right-panel { display: none; } /* 手机上隐藏两侧面板，只留导航 */
            .center-panel { width: 100%; transform: none; }
            .nav-grid { flex-wrap: wrap; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div class="cinematic-bar">
        <div>SYS: ONLINE</div>
        <div class="warning-text">GRAVITY WELL DETECTED</div>
        <div>T-MINUS: NULL</div>
    </div>

    <div id="hud-container">
        <div class="panel left-panel">
            <div style="border-bottom: 1px solid var(--neon-blue); width:100%; padding-bottom:5px; margin-bottom:10px;">REACTOR STATUS</div>
            <div class="data-row"><span>CORE TEMP</span><span>3,400 K</span></div>
            <div class="data-row"><span>SHIELD</span><span>98%</span></div>
            <div class="data-row"><span>WARP DRIVE</span><span>CHARGING</span></div>
            <div class="bar-chart">
                <div class="bar" style="animation-delay: 0.1s"></div>
                <div class="bar" style="animation-delay: 0.3s"></div>
                <div class="bar" style="animation-delay: 0.5s"></div>
                <div class="bar" style="animation-delay: 0.2s"></div>
                <div class="bar" style="animation-delay: 0.4s"></div>
            </div>
        </div>

        <div class="panel center-panel">
            <div class="nav-grid" id="nav-container">
                </div>
        </div>

        <div class="panel right-panel">
            <div class="radar-circle">
                <div class="radar-scan"></div>
                <div style="position:absolute; top:50%; left:50%; width:4px; height:4px; background:#fff; transform:translate(-50%,-50%); border-radius:50%;"></div>
            </div>
            <div style="margin-top:10px; font-size:10px; letter-spacing:1px; color:var(--neon-blue);">PROXIMITY ALERT</div>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. 导航配置 (在这里修改你的链接)
        // ==========================================
        const navItems = [
            { title: "HOME", sub: "主舰桥", link: "/" },
            { title: "BLOG", sub: "航行日志", link: "/visual" },
            { title: "WORKS", sub: "武器库", link: "/colliding-ball" },
            { title: "GITHUB", sub: "源代码", link: "https://github.com" }
        ];

        const navContainer = document.getElementById('nav-container');
        navItems.forEach(item => {
            const a = document.createElement('a');
            a.href = item.link;
            a.className = 'nav-btn';
            a.innerHTML = `<h3>${item.title}</h3><span>${item.sub}</span>`;
            navContainer.appendChild(a);
        });

        // ==========================================
        // 2. Three.js 黑洞与时空扭曲渲染
        // ==========================================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 80); // 相机位置拉高，俯视黑洞
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- A. 黑洞本体 (Event Horizon) ---
        const blackHoleGeo = new THREE.SphereGeometry(10, 64, 64);
        const blackHoleMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const blackHole = new THREE.Mesh(blackHoleGeo, blackHoleMat);
        scene.add(blackHole);

        // --- B. 吸积盘 (Accretion Disk) - 发光的环 ---
        // 使用两个环，模拟复杂的吸积盘
        const diskGeo = new THREE.RingGeometry(12, 35, 64);
        // 让环稍微倾斜一点
        diskGeo.rotateX(-Math.PI / 2); 
        
        // 自定义材质实现光晕效果
        const diskMat = new THREE.MeshBasicMaterial({ 
            color: 0xffaa00, // 橙色/琥珀色，像星际穿越那样
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending 
        });
        const disk = new THREE.Mesh(diskGeo, diskMat);
        // scene.add(disk);

        // --- C. 时空网格 (Space-Time Grid) ---
        // 关键点：分段数要足够多，才能表现出平滑的扭曲
        const gridSegments = 100;
        const gridSize = 300;
        const gridGeo = new THREE.PlaneGeometry(gridSize, gridSize, gridSegments, gridSegments);
        gridGeo.rotateX(-Math.PI / 2);

        // 保存原始顶点位置，用于动画计算
        const originalPositions = gridGeo.attributes.position.array.slice();

        const gridMat = new THREE.MeshBasicMaterial({ 
            color: 0x00f3ff, 
            wireframe: true,
            transparent: true,
            opacity: 0.15 
        });
        const grid = new THREE.Mesh(gridGeo, gridMat);
        scene.add(grid);

        // --- D. 粒子星空 ---
        const starsGeo = new THREE.BufferGeometry();
        const starCount = 2000;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) {
            starPos[i] = (Math.random() - 0.5) * 600;
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true });
        const starSystem = new THREE.Points(starsGeo, starsMat);
        scene.add(starSystem);


        // ==========================================
        // 3. 物理与动画循环
        // ==========================================
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // 1. 网格扭曲计算 (核心算法)
            const positions = grid.geometry.attributes.position.array;
            
            for(let i = 0; i < positions.length; i += 3) {
                // 获取原始平面的坐标 (x, 0, z)
                // 注意：由于我们旋转了平面，原来的 z 轴现在对应世界坐标的 z (深度)，y 是高度
                // 在 PlaneGeometry 原始数据中，z 是 0。旋转后，buffer 里的坐标被变换了吗？
                // ThreeJS 的 geometry.rotateX 实际上改变了顶点数据。
                // 现在的 positions[i+1] 是 y (高度), positions[i+2] 是 z.
                
                let x = originalPositions[i];
                let z = originalPositions[i+2]; // 原始的Z实际上是平面的Y轴方向，但因为旋转了...
                
                // 纠正：使用原始数据的映射。
                // 原始 Plane: X=x, Y=y, Z=0. 
                // RotateX(-90): X=x, Y=0, Z=y.
                // 我们直接读取当前的 x 和 z
                x = positions[i];
                z = positions[i+2];

                // 计算到中心的距离
                const dist = Math.sqrt(x*x + z*z);
                
                // 避免除以0
                const safeDist = Math.max(10, dist);

                // --- 效果1: 引力井 (Gravity Well) ---
                // 距离越近，Y值越低 (向下陷)
                // 公式： -Factor / dist
                const gravity = -2000 / (safeDist * safeDist + 100) * 15;
                positions[i+1] = gravity;

                // --- 效果2: 参考系拖拽 (Frame Dragging) ---
                // 距离越近，旋转角度越大
                // 我们需要手动旋转顶点 (x,z) 围绕原点 (0,0)
                // 扭曲因子：越近越大
                const twistAngle = (30 / safeDist) * Math.sin(time * 0.5) * 0.5; 
                // 为了让它看起来像漩涡，加上一个固定的旋转偏移
                const spiralAngle = -time * 2 * (50 / safeDist); 

                // 简单的实现：我们不改变 x 和 z 的物理位置太剧烈，否则网格会乱。
                // 我们主要通过颜色或者微调 UV 来做？
                // 不，直接修改 Y 已经很有引力感了。
                // 为了增加动感，我们叠加一个波动：
                positions[i+1] += Math.sin(dist * 0.2 - time * 5) * 2;
            }
            grid.geometry.attributes.position.needsUpdate = true;

            // 2. 吸积盘旋转
            disk.rotation.z = time * 0.2; // 自身旋转
            // 让吸积盘有点波动
            disk.rotation.x = -Math.PI / 2 + Math.sin(time) * 0.1;

            // 3. 粒子系统缓慢旋转
            starSystem.rotation.y = time * 0.05;

            // 4. 摄像机微动 (呼吸感)
            camera.position.y = 30 + Math.sin(time * 0.5) * 2;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        // 窗口自适应
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>